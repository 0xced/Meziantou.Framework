using System.Collections.Immutable;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Meziantou.Framework.StronglyTypedId;

[Generator]
public sealed partial class StronglyTypedIdSourceGenerator : IIncrementalGenerator
{
    private static readonly string Version = Assembly.GetExecutingAssembly().GetName().Version?.ToString() ?? "1.0.0";

    private const string FieldName = "_value";
    private const string PropertyName = "Value";
    private const string PropertyAsStringName = "ValueAsString";

    [SuppressMessage("Usage", "MA0101:String contains an implicit end of line character", Justification = "Not important")]
    private const string AttributeText = """
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

[System.Diagnostics.Conditional("StronglyTypedId_Attributes")]
[System.AttributeUsage(System.AttributeTargets.Struct | System.AttributeTargets.Class)]
internal sealed class StronglyTypedIdAttribute : System.Attribute
{
    /// <summary>
    /// Indicate the type is a strongly-typed id
    /// </summary>
    /// <param name="idType">Type of the generated Value</param>
    /// <param name="generateSystemTextJsonConverter">Specify if the <see cref="System.Text.Json.Serialization.JsonConverter"/> should be generated</param>
    /// <param name="generateNewtonsoftJsonConverter">Specify if the <see cref="Newtonsoft.Json.JsonConverter"/> should be generated</param>
    /// <param name="generateSystemComponentModelTypeConverter">Specify if the <see cref="System.ComponentModel.TypeConverter"/> should be generated</param>
    /// <param name="generateMongoDBBsonSerialization">Specify if the <see cref="MongoDB.Bson.Serialization.Serializers.SerializerBase{T}"/> should be generated</param>
    /// <param name="addCodeGeneratedAttribute">Add <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> to the generated members</param>
    public StronglyTypedIdAttribute(System.Type idType,
                                    bool generateSystemTextJsonConverter = true,
                                    bool generateNewtonsoftJsonConverter = true,
                                    bool generateSystemComponentModelTypeConverter = true,
                                    bool generateMongoDBBsonSerialization = true,
                                    bool addCodeGeneratedAttribute = true)
    {
    }
}
""";

    private static readonly DiagnosticDescriptor UnsuportedType = new(
        id: "MFSTID0001",
        title: "Not supported type",
        messageFormat: "The type '{0}' is not supported",
        category: "StronglyTypedId",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("StronglyTypedIdAttribute.g.cs", SourceText.From(AttributeText, Encoding.UTF8)));

        var types = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (syntax, cancellationToken) => IsSyntaxTargetForGeneration(syntax),
                transform: static (ctx, cancellationToken) => GetSemanticTargetForGeneration(ctx, cancellationToken))
            .Where(static m => m is not null)!
            .WithTrackingName("Syntax");

        var compilation = context.CompilationProvider
            .Select((compilation, cancellationToken) => new CompilationInfo(compilation))
            .WithComparer(EqualityComparer<CompilationInfo>.Default)
            .WithTrackingName("Compilation");

        var typesToProcess = types.Combine(compilation);

        context.RegisterSourceOutput(typesToProcess,
            (spc, source) => Execute(spc, source.Right, source.Left!));

        static bool IsSyntaxTargetForGeneration(SyntaxNode syntax)
        {
            return (syntax.IsKind(SyntaxKind.StructDeclaration) || syntax.IsKind(SyntaxKind.ClassDeclaration) || syntax.IsKind(SyntaxKind.RecordDeclaration) || syntax.IsKind(SyntaxKind.RecordStructDeclaration)) &&
                   ((TypeDeclarationSyntax)syntax).AttributeLists.Count > 0;
        }

        static AttributeInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext ctx, CancellationToken cancellationToken)
        {
            var semanticModel = ctx.SemanticModel;
            var compilation = semanticModel.Compilation;
            var typeDeclaration = (TypeDeclarationSyntax)ctx.Node;

            var attributeSymbol = compilation.GetTypeByMetadataName("StronglyTypedIdAttribute");
            if (attributeSymbol == null)
                return null;

            var symbol = semanticModel.GetDeclaredSymbol(typeDeclaration, cancellationToken);
            if (symbol == null)
                return null;

            foreach (var attribute in symbol.GetAttributes())
            {
                if (attributeSymbol.Equals(attribute.AttributeClass, SymbolEqualityComparer.Default))
                    return GetAttributeInfo(semanticModel, attributeSymbol, symbol, cancellationToken);
            }

            return null;
        }
    }

    private static void Execute(SourceProductionContext context, CompilationInfo compilation, AttributeInfo attribute)
    {
        if (attribute.IdType == IdType.Unknown)
        {
            context.ReportDiagnostic(Diagnostic.Create(UnsuportedType, attribute.AttributeSyntax.GetLocation(), attribute.IdType));
            return;
        }

        var stronglyTypedId = new StronglyTypedIdInfo(compilation, attribute);

        var writer = new CSharpGeneratedFileWriter();
        writer.WriteLine("#nullable enable");

        var baseTypes = $"global::System.IEquatable<{stronglyTypedId.Name}>";
        if (stronglyTypedId.CanImplementIParsable())
        {
            baseTypes += $", global::System.IParsable<{stronglyTypedId.Name}>";
        }

        if (stronglyTypedId.CanImplementISpanParsable())
        {
            baseTypes += $", global::System.ISpanParsable<{stronglyTypedId.Name}>";
        }

        var attributes = (CSharpGeneratedFileWriter writer) =>
        {
            if (stronglyTypedId.CanGenerateTypeConverter())
            {
                writer.WriteLine($"[global::System.ComponentModel.TypeConverterAttribute(typeof({stronglyTypedId.TypeConverterTypeName}))]");
            }

            if (stronglyTypedId.CanGenerateSystemTextJsonConverter())
            {
                writer.WriteLine($"[global::System.Text.Json.Serialization.JsonConverterAttribute(typeof({stronglyTypedId.SystemTextJsonConverterTypeName}))]");
            }

            if (stronglyTypedId.CanGenerateMongoDbConverter())
            {
                writer.WriteLine($"[global::MongoDB.Bson.Serialization.Attributes.BsonSerializerAttribute(typeof({stronglyTypedId.MongoDbConverterTypeName}))]");
            }

            if (stronglyTypedId.CanGenerateNewtonsoftJsonConverter())
            {
                writer.WriteLine($"[global::Newtonsoft.Json.JsonConverterAttribute(typeof({stronglyTypedId.NewtonsoftJsonConverterTypeName}))]");
            }
        };

        using (writer.BeginPartialContext(stronglyTypedId.TypeSymbol, attributes, baseTypes))
        {
            GenerateTypeMembers(writer, stronglyTypedId);
            GenerateTypeConverter(writer, stronglyTypedId);
            GenerateSystemTextJsonConverter(writer, stronglyTypedId);
            GenerateMongoDBBsonSerializationConverter(writer, stronglyTypedId);
            GenerateNewtonsoftJsonConverter(writer, stronglyTypedId);
        }

        context.AddSource(stronglyTypedId.Name + ".g.cs", writer.ToSourceText());
    }

    private static void WriteNewMember(CSharpGeneratedFileWriter writer, StronglyTypedIdInfo info, bool addNewLine)
    {
        if (addNewLine)
        {
            writer.WriteLine();
        }

        if (info.AttributeInfo.AddCodeGeneratedAttribute)
        {

            writer.WriteLine($"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Meziantou.Framework.StronglyTypedId\", \"{Version}\")]");
        }
    }

    private static AttributeInfo? GetAttributeInfo(SemanticModel semanticModel, ITypeSymbol attributeSymbol, INamedTypeSymbol declaredTypeSymbol, CancellationToken cancellationToken)
    {
        foreach (var attribute in declaredTypeSymbol.GetAttributes())
        {
            if (!SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, attributeSymbol))
                continue;

            var arguments = attribute.ConstructorArguments;
            if (arguments.Length != 6)
                continue;

            var idTypeArgument = arguments[0];
            if (idTypeArgument.Value is not ITypeSymbol type)
                continue;

            var converters = StronglyTypedIdConverters.None;
            AddConverter(arguments[1], StronglyTypedIdConverters.System_Text_Json);
            AddConverter(arguments[2], StronglyTypedIdConverters.Newtonsoft_Json);
            AddConverter(arguments[3], StronglyTypedIdConverters.System_ComponentModel_TypeConverter);
            AddConverter(arguments[4], StronglyTypedIdConverters.MongoDB_Bson_Serialization);
            void AddConverter(TypedConstant value, StronglyTypedIdConverters converterValue)
            {
                if (value.Value is bool argumentValue && argumentValue)
                {
                    converters |= converterValue;
                }
            }

            var addCodeGeneratedAttribute = false;
            if (arguments[5].Value is bool addCodeGeneratedAttributeValue)
            {
                addCodeGeneratedAttribute = addCodeGeneratedAttributeValue;
            }

            var attributeSyntax = attribute.ApplicationSyntaxReference.GetSyntax(cancellationToken);
            var idType = GetIdType(semanticModel.Compilation, type);

            var typeSyntaxes = GetNodes(declaredTypeSymbol.DeclaringSyntaxReferences, cancellationToken);
            return new AttributeInfo(attributeSyntax, typeSyntaxes, declaredTypeSymbol, idType, type, converters, addCodeGeneratedAttribute);

            static SyntaxNode[] GetNodes(ImmutableArray<SyntaxReference> syntaxReferences, CancellationToken cancellationToken)
            {
                var result = new SyntaxNode[syntaxReferences.Length];
                var span = syntaxReferences.AsSpan();
                for (var i = 0; i < span.Length; i++)
                {
                    result[i] = span[i].GetSyntax(cancellationToken);
                }

                return result;
            }
        }

        return null;
    }

    private static IdType GetIdType(Compilation compilation, ITypeSymbol symbol)
    {
        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_Boolean)))
            return IdType.System_Boolean;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_Byte)))
            return IdType.System_Byte;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_DateTime)))
            return IdType.System_DateTime;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.DateTimeOffset")))
            return IdType.System_DateTimeOffset;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_Decimal)))
            return IdType.System_Decimal;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_Double)))
            return IdType.System_Double;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Guid")))
            return IdType.System_Guid;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Half")))
            return IdType.System_Half;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_Int16)))
            return IdType.System_Int16;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_Int32)))
            return IdType.System_Int32;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_Int64)))
            return IdType.System_Int64;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Int128")))
            return IdType.System_Int128;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Numerics.BigInteger")))
            return IdType.System_Numerics_BigInteger;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_SByte)))
            return IdType.System_SByte;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_Single)))
            return IdType.System_Single;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_String)))
            return IdType.System_String;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_UInt16)))
            return IdType.System_UInt16;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_UInt32)))
            return IdType.System_UInt32;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetSpecialType(SpecialType.System_UInt64)))
            return IdType.System_UInt64;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.UInt128")))
            return IdType.System_UInt128;

        return IdType.Unknown;
    }

    private static string GetTypeReference(IdType type)
    {
        return type switch
        {
            IdType.System_Boolean => "bool",
            IdType.System_Byte => "byte",
            IdType.System_DateTime => "global::System.DateTime",
            IdType.System_DateTimeOffset => "global::System.DateTimeOffset",
            IdType.System_Decimal => "decimal",
            IdType.System_Double => "double",
            IdType.System_Guid => "global::System.Guid",
            IdType.System_Half => "global::System.Half",
            IdType.System_Int16 => "short",
            IdType.System_Int32 => "int",
            IdType.System_Int64 => "long",
            IdType.System_Int128 => "global::System.Int128",
            IdType.System_Numerics_BigInteger => "global::System.Numerics.BigInteger",
            IdType.System_SByte => "sbyte",
            IdType.System_Single => "float",
            IdType.System_String => "string",
            IdType.System_UInt16 => "ushort",
            IdType.System_UInt32 => "uint",
            IdType.System_UInt64 => "ulong",
            IdType.System_UInt128 => "global::System.UInt128",
            _ => throw new ArgumentException("Type not supported", nameof(type)),
        };
    }

    private static bool IsNullable(IdType idType)
    {
        return idType == IdType.System_String;
    }

    private static string GetShortName(IdType type)
    {
        return type switch
        {
            IdType.System_Boolean => "Boolean",
            IdType.System_Byte => "Byte",
            IdType.System_DateTime => "DateTime",
            IdType.System_DateTimeOffset => "DateTimeOffset",
            IdType.System_Decimal => "Decimal",
            IdType.System_Double => "Double",
            IdType.System_Guid => "Guid",
            IdType.System_Half => "Half",
            IdType.System_Int16 => "Int16",
            IdType.System_Int32 => "Int32",
            IdType.System_Int64 => "Int64",
            IdType.System_Int128 => "Int128",
            IdType.System_Numerics_BigInteger => "BigInteger",
            IdType.System_SByte => "SByte",
            IdType.System_Single => "Single",
            IdType.System_String => "String",
            IdType.System_UInt16 => "UInt16",
            IdType.System_UInt32 => "UInt32",
            IdType.System_UInt64 => "UInt64",
            IdType.System_UInt128 => "UInt128",
            _ => throw new ArgumentException("Type not supported", nameof(type)),
        };
    }

    private static string GetPrivateOrProtectedModifier(StronglyTypedIdInfo type)
    {
        if (type.IsReferenceType && !type.IsSealed)
            return "protected";

        return "private";
    }

    private sealed class AttributeInfo : IEquatable<AttributeInfo>
    {
        private readonly SyntaxNode[] _typeSyntaxes;

        public AttributeInfo(SyntaxNode attributeSyntax, SyntaxNode[] typeSyntaxes, INamedTypeSymbol typeSymbol, IdType idType, ISymbol idTypeSymbol, StronglyTypedIdConverters converters, bool addCodeGeneratedAttribute)
        {
            AttributeSyntax = attributeSyntax;
            _typeSyntaxes = typeSyntaxes;
            TypeSymbol = typeSymbol;
            IdType = idType;
            IdTypeSymbol = idTypeSymbol;
            Converters = converters;
            AddCodeGeneratedAttribute = addCodeGeneratedAttribute;
        }

        public SyntaxNode AttributeSyntax { get; }
        public INamedTypeSymbol TypeSymbol { get; }
        public IdType IdType { get; }
        public ISymbol IdTypeSymbol { get; }
        public StronglyTypedIdConverters Converters { get; }
        public bool AddCodeGeneratedAttribute { get; }

        public override bool Equals(object? obj) => Equals(obj as AttributeInfo);

        public bool Equals(AttributeInfo? other)
        {
            // Do not use TypeSymbol as it cannot be compared across Compilation.
            return other is not null
                && ArrayEqualityComparer<SyntaxNode>.Default.Equals(_typeSyntaxes, other._typeSyntaxes)
                && IdType == other.IdType
                && Converters == other.Converters
                && AddCodeGeneratedAttribute == other.AddCodeGeneratedAttribute;
        }

        public override int GetHashCode()
        {
            var hash = TypeSymbol.IsValueType.GetHashCode();
            hash = (hash * 397) ^ ArrayEqualityComparer<SyntaxNode>.Default.GetHashCode(_typeSyntaxes);
            hash = (hash * 397) ^ IdType.GetHashCode();
            hash = (hash * 397) ^ Converters.GetHashCode();
            hash = (hash * 397) ^ AddCodeGeneratedAttribute.GetHashCode();
            return hash;
        }
    }

    private sealed class CompilationInfo : IEquatable<CompilationInfo?>
    {
        public bool SupportStaticInterfaces { get; }
        public INamedTypeSymbol? StronglyTypedIdAttribute { get; }
        public INamedTypeSymbol? ReadOnlySpan_Char { get; }
        public INamedTypeSymbol? IParsable { get; }
        public INamedTypeSymbol? ISpanParsable { get; }
        public INamedTypeSymbol? TypeConverter { get; }
        public INamedTypeSymbol? SystemTextJsonConverter { get; }
        public INamedTypeSymbol? NewtonsoftJsonConverter { get; }
        public INamedTypeSymbol? MongoDbConverter { get; }
        public INamedTypeSymbol? NotNullWhenAttribute { get; }

        public CompilationInfo(Compilation compilation)
        {
            StronglyTypedIdAttribute = compilation.GetTypeByMetadataName("StronglyTypedIdAttribute");
            IParsable = compilation.GetTypeByMetadataName("System.IParsable`1");
            ISpanParsable = compilation.GetTypeByMetadataName("System.ISpanParsable`1");
            TypeConverter = compilation.GetTypeByMetadataName("System.ComponentModel.TypeConverter");
            SystemTextJsonConverter = compilation.GetTypeByMetadataName("System.Text.Json.Serialization.JsonConverter`1");
            NewtonsoftJsonConverter = compilation.GetTypeByMetadataName("Newtonsoft.Json.JsonConverter");
            MongoDbConverter = compilation.GetTypeByMetadataName("MongoDB.Bson.Serialization.Serializers.SerializerBase`1");
            NotNullWhenAttribute = compilation.GetTypeByMetadataName("System.Diagnostics.CodeAnalysis.NotNullWhenAttribute");

            var readOnlySpan = compilation.GetTypeByMetadataName("System.ReadOnlySpan`1");
            if (readOnlySpan != null)
            {
                var charSymbol = compilation.GetSpecialType(SpecialType.System_Char);
                ReadOnlySpan_Char = readOnlySpan.Construct(charSymbol);
            }

            // Supported by C# 10 (preview) or greater
            SupportStaticInterfaces = compilation.SyntaxTrees.FirstOrDefault()?.Options is CSharpParseOptions options && options.LanguageVersion is >= (LanguageVersion)1100 or LanguageVersion.Preview;
        }

        public override bool Equals(object? obj) => Equals(obj as CompilationInfo);

        public bool Equals(CompilationInfo? other)
        {
            // Do not compare StronglyTypedIdAttribute. This attribute is added by the SourceGenerator, so it does exist.
            // Also, the comparison returns false, which prevent caching from the source generator
            return other is not null
                && SupportStaticInterfaces == other.SupportStaticInterfaces
                && SymbolEqualityComparer.Default.Equals(ReadOnlySpan_Char, other.ReadOnlySpan_Char)
                && SymbolEqualityComparer.Default.Equals(IParsable, other.IParsable)
                && SymbolEqualityComparer.Default.Equals(ISpanParsable, other.ISpanParsable)
                && SymbolEqualityComparer.Default.Equals(TypeConverter, other.TypeConverter)
                && SymbolEqualityComparer.Default.Equals(SystemTextJsonConverter, other.SystemTextJsonConverter)
                && SymbolEqualityComparer.Default.Equals(NewtonsoftJsonConverter, other.NewtonsoftJsonConverter)
                && SymbolEqualityComparer.Default.Equals(MongoDbConverter, other.MongoDbConverter)
                && SymbolEqualityComparer.Default.Equals(NotNullWhenAttribute, other.NotNullWhenAttribute);
        }

        public override int GetHashCode()
        {
            var hash = SupportStaticInterfaces.GetHashCode();
            hash = (hash * 397) ^ SymbolEqualityComparer.Default.GetHashCode(ReadOnlySpan_Char);
            hash = (hash * 397) ^ SymbolEqualityComparer.Default.GetHashCode(IParsable);
            hash = (hash * 397) ^ SymbolEqualityComparer.Default.GetHashCode(ISpanParsable);
            hash = (hash * 397) ^ SymbolEqualityComparer.Default.GetHashCode(TypeConverter);
            hash = (hash * 397) ^ SymbolEqualityComparer.Default.GetHashCode(SystemTextJsonConverter);
            hash = (hash * 397) ^ SymbolEqualityComparer.Default.GetHashCode(NewtonsoftJsonConverter);
            hash = (hash * 397) ^ SymbolEqualityComparer.Default.GetHashCode(MongoDbConverter);
            hash = (hash * 397) ^ SymbolEqualityComparer.Default.GetHashCode(NotNullWhenAttribute);
            return hash;
        }
    }

    private sealed record StronglyTypedIdInfo(CompilationInfo CompilationInfo, AttributeInfo AttributeInfo)
    {
        public string Name => TypeSymbol.Name;
        public INamedTypeSymbol TypeSymbol => AttributeInfo.TypeSymbol;

        public bool IsClass => TypeSymbol.IsReferenceType && !TypeSymbol.IsRecord;
        public bool IsRecord => TypeSymbol.IsReferenceType && TypeSymbol.IsRecord;
        public bool IsStruct => !TypeSymbol.IsReferenceType && !TypeSymbol.IsRecord;
        public bool IsRecordStruct => !TypeSymbol.IsReferenceType && TypeSymbol.IsRecord;
        public bool IsReferenceType => TypeSymbol.IsReferenceType;

        public bool IsSealed => TypeSymbol.IsSealed;

        public bool IsCtorDefined()
        {
            return TypeSymbol != null && TypeSymbol.GetMembers(".ctor").OfType<IMethodSymbol>()
                .Any(m => !m.IsStatic && m.Parameters.Length == 1 && SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, AttributeInfo.IdTypeSymbol));
        }

        public bool IsFieldDefined()
        {
            return TypeSymbol != null && TypeSymbol.GetMembers(FieldName).Any();
        }

        public bool IsValueDefined()
        {
            return TypeSymbol != null && TypeSymbol.GetMembers(PropertyName).Any();
        }

        public bool IsValueAsStringDefined()
        {
            return TypeSymbol != null && TypeSymbol.GetMembers(PropertyAsStringName).Any();
        }

        public bool IsToStringDefined()
        {
            return TypeSymbol != null && TypeSymbol.GetMembers(nameof(ToString)).OfType<IMethodSymbol>()
                .Any(m => !m.IsStatic && m.Parameters.Length == 0 && m.ReturnType?.SpecialType == SpecialType.System_String);
        }

        public bool IsGetHashcodeDefined()
        {
            return TypeSymbol != null && TypeSymbol.GetMembers(nameof(GetHashCode)).OfType<IMethodSymbol>()
                .Any(m => !m.IsStatic && m.Parameters.Length == 0 && m.ReturnType?.SpecialType == SpecialType.System_Int32);
        }

        public bool IsEqualsDefined()
        {
            return TypeSymbol != null && TypeSymbol.GetMembers(nameof(Equals)).OfType<IMethodSymbol>()
                .Any(m => !m.IsStatic && m.Parameters.Length == 1 && m.Parameters[0].Type.SpecialType == SpecialType.System_Object && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
        }

        public bool IsIEquatableEqualsDefined()
        {
            return TypeSymbol != null && Enumerable.OfType<IMethodSymbol>(TypeSymbol.GetMembers(nameof(Equals)))
                .Any(m => !m.IsStatic && m.Parameters.Length == 1 && SymbolEqualityComparer.Default.Equals(TypeSymbol, m.Parameters[0].Type) && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
        }

        public bool IsOpEqualsDefined()
        {
            return TypeSymbol != null && Enumerable.OfType<IMethodSymbol>(TypeSymbol.GetMembers("op_Equality"))
                .Any(m => m.IsStatic && m.Parameters.Length == 2 && SymbolEqualityComparer.Default.Equals(TypeSymbol, m.Parameters[0].Type) && SymbolEqualityComparer.Default.Equals(TypeSymbol, m.Parameters[1].Type) && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
        }

        public bool IsOpNotEqualsDefined()
        {
            return TypeSymbol != null && Enumerable.OfType<IMethodSymbol>(TypeSymbol.GetMembers("op_Inequality"))
                .Any(m => m.IsStatic && m.Parameters.Length == 2 && SymbolEqualityComparer.Default.Equals(TypeSymbol, m.Parameters[0].Type) && SymbolEqualityComparer.Default.Equals(TypeSymbol, m.Parameters[1].Type) && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
        }

        public bool IsTryParseDefined_String()
        {
            return TypeSymbol != null && TypeSymbol.GetMembers("TryParse").OfType<IMethodSymbol>()
                .Any(m => m.IsStatic && m.Parameters.Length > 0 && m.Parameters[0].Type.SpecialType == SpecialType.System_String);
        }

        public bool IsTryParseDefined_ReadOnlySpan()
        {
            var type = CompilationInfo.ReadOnlySpan_Char;
            if (type == null)
                return false;

            return TypeSymbol != null && TypeSymbol.GetMembers("TryParse").OfType<IMethodSymbol>()
                .Any(m => m.IsStatic && m.Parameters.Length > 0 && SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, type));
        }

        public bool IsParseDefined_String()
        {
            return TypeSymbol != null && TypeSymbol.GetMembers("Parse").OfType<IMethodSymbol>()
                .Any(m => m.IsStatic && m.Parameters.Length > 0 && m.Parameters[0].Type.SpecialType == SpecialType.System_String);
        }

        public bool IsParseDefined_Span()
        {
            var type = CompilationInfo.ReadOnlySpan_Char;
            if (type == null)
                return false;

            return TypeSymbol != null && TypeSymbol.GetMembers("Parse").OfType<IMethodSymbol>()
                .Any(m => m.IsStatic && m.Parameters.Length > 0 && SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, type));
        }

        public bool SupportReadOnlySpan() => CompilationInfo.ReadOnlySpan_Char != null;

        public bool CanImplementISpanParsable()
        {
            return CompilationInfo.SupportStaticInterfaces && SupportReadOnlySpan() && CompilationInfo.ISpanParsable != null;
        }

        public bool CanImplementIParsable()
        {
            return CompilationInfo.SupportStaticInterfaces && SupportReadOnlySpan() && CompilationInfo.IParsable != null;
        }

        public bool CanGenerateTypeConverter()
        {
            return AttributeInfo.Converters.HasFlag(StronglyTypedIdConverters.System_ComponentModel_TypeConverter)
                && CompilationInfo.TypeConverter != null;
        }

        public bool CanGenerateSystemTextJsonConverter()
        {
            return AttributeInfo.Converters.HasFlag(StronglyTypedIdConverters.System_Text_Json)
                && CompilationInfo.SystemTextJsonConverter != null;
        }

        public bool CanGenerateNewtonsoftJsonConverter()
        {
            return AttributeInfo.Converters.HasFlag(StronglyTypedIdConverters.Newtonsoft_Json)
                && CompilationInfo.NewtonsoftJsonConverter != null;
        }

        public bool CanGenerateMongoDbConverter()
        {
            return AttributeInfo.Converters.HasFlag(StronglyTypedIdConverters.MongoDB_Bson_Serialization)
                && CompilationInfo.MongoDbConverter != null;
        }

        public string TypeConverterTypeName => Name + "TypeConverter";
        public string SystemTextJsonConverterTypeName => Name + "JsonConverter";
        public string NewtonsoftJsonConverterTypeName => Name + "NewtonsoftJsonConverter";
        public string MongoDbConverterTypeName => Name + "BsonConverter";
    }

    [Flags]
    private enum StronglyTypedIdConverters
    {
        None = 0x0,
        System_Text_Json = 0x1,
        Newtonsoft_Json = 0x2,
        System_ComponentModel_TypeConverter = 0x4,
        MongoDB_Bson_Serialization = 0x8,
    }

    private enum IdType
    {
        Unknown,
        System_Boolean,
        System_Byte,
        System_DateTime,
        System_DateTimeOffset,
        System_Decimal,
        System_Double,
        System_Guid,
        System_Half,
        System_Int16,
        System_Int32,
        System_Int64,
        System_Int128,
        System_Numerics_BigInteger,
        System_SByte,
        System_Single,
        System_String,
        System_UInt16,
        System_UInt32,
        System_UInt64,
        System_UInt128,
    }
}
