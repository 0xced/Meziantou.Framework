using System.Diagnostics;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Meziantou.Framework.StronglyTypedId;

// TODO1 AddCodeGeneratedAttributeVisitor
// TODO1 Int128 / UInt128 / BigInteger / Half / Any type that have a specific constraint?
//      https://github.com/dotnet/runtime/blob/88868b7a781f4e5b9037b8721f30440207a7aa42/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/ConvertersForUnsupportedTypesFunctionalTests.cs#L96
// TODO1 Generate code using global::?

[Generator]
public sealed partial class StronglyTypedIdSourceGenerator : IIncrementalGenerator
{
    private static readonly string Version = Assembly.GetExecutingAssembly().GetName().Version?.ToString() ?? "1.0.0";

    private const string FieldName = "_value";
    private const string PropertyName = "Value";
    private const string PropertyAsStringName = "ValueAsString";

    [SuppressMessage("Usage", "MA0101:String contains an implicit end of line character", Justification = "Not important")]
    private const string AttributeText = """
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

[System.Diagnostics.Conditional("StronglyTypedId_Attributes")]
[System.AttributeUsage(System.AttributeTargets.Struct | System.AttributeTargets.Class)]
internal sealed class StronglyTypedIdAttribute : System.Attribute
{
    /// <summary>
    /// Indicate the type is a strongly-typed id
    /// </summary>
    /// <param name="idType">Type of the generated Value</param>
    /// <param name="generateSystemTextJsonConverter">Specify if the <see cref="System.Text.Json.Serialization.JsonConverter"/> should be generated</param>
    /// <param name="generateNewtonsoftJsonConverter">Specify if the <see cref="Newtonsoft.Json.JsonConverter"/> should be generated</param>
    /// <param name="generateSystemComponentModelTypeConverter">Specify if the <see cref="System.ComponentModel.TypeConverter"/> should be generated</param>
    /// <param name="generateMongoDBBsonSerialization">Specify if the <see cref="MongoDB.Bson.Serialization.Serializers.SerializerBase{T}"/> should be generated</param>
    /// <param name="addCodeGeneratedAttribute">Add <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> to the generated members</param>
    public StronglyTypedIdAttribute(System.Type idType,
                                    bool generateSystemTextJsonConverter = true,
                                    bool generateNewtonsoftJsonConverter = true,
                                    bool generateSystemComponentModelTypeConverter = true,
                                    bool generateMongoDBBsonSerialization = true,
                                    bool addCodeGeneratedAttribute = true)
    {
    }
}
""";

    private static readonly DiagnosticDescriptor UnsuportedType = new(
        id: "MFSTID0001",
        title: "Not supported type",
        messageFormat: "The type '{0}' is not supported",
        category: "StronglyTypedId",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("StronglyTypedIdAttribute.g.cs", SourceText.From(AttributeText, Encoding.UTF8)));

        var types = context.SyntaxProvider.CreateSyntaxProvider(
          predicate: static (syntax, cancellationToken) => IsSyntaxTargetForGeneration(syntax),
          transform: static (ctx, cancellationToken) => GetSemanticTargetForGeneration(ctx, cancellationToken))
              .Where(static m => m is not null)!;

        var typesToProcess = types.Combine(context.CompilationProvider);

        context.RegisterSourceOutput(typesToProcess,
            (spc, source) => Execute(spc, source.Right, source.Left!));

        static bool IsSyntaxTargetForGeneration(SyntaxNode syntax)
        {
            return (syntax.IsKind(SyntaxKind.StructDeclaration) || syntax.IsKind(SyntaxKind.ClassDeclaration) || syntax.IsKind(SyntaxKind.RecordDeclaration) || syntax.IsKind(SyntaxKind.RecordStructDeclaration)) &&
                   ((TypeDeclarationSyntax)syntax).AttributeLists.Count > 0;
        }

        static TypeDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext ctx, CancellationToken cancellationToken)
        {
            var semanticModel = ctx.SemanticModel;
            var compilation = semanticModel.Compilation;
            var typeDeclaration = (TypeDeclarationSyntax)ctx.Node;

            var attributeSymbol = compilation.GetTypeByMetadataName("StronglyTypedIdAttribute");
            if (attributeSymbol == null)
                return null;

            var symbol = semanticModel.GetDeclaredSymbol(typeDeclaration, cancellationToken);
            if (symbol == null)
                return null;

            foreach (var attribute in symbol.GetAttributes())
            {
                if (attributeSymbol.Equals(attribute.AttributeClass, SymbolEqualityComparer.Default))
                    return typeDeclaration;
            }

            return null;
        }
    }

    private static void Execute(SourceProductionContext context, Compilation compilation, TypeDeclarationSyntax typeDeclaration)
    {
        var attributeSymbol = compilation.GetTypeByMetadataName("StronglyTypedIdAttribute");
        Debug.Assert(attributeSymbol != null);

        var semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
        var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration, context.CancellationToken)!;
        var attributeInfo = GetAttributeInfo(context, semanticModel, attributeSymbol, typeSymbol);
        if (attributeInfo == null)
            return;

        var stronglyTypedId = new StronglyTypedIdInfo(compilation, typeSymbol.ContainingSymbol, typeSymbol, typeSymbol.Name, attributeInfo, typeDeclaration);

        var writer = new CSharpGeneratedFileWriter();
        writer.WriteLine("#nullable enable");

        var baseTypes = $"global::System.IEquatable<{stronglyTypedId.Name}>";
        if (stronglyTypedId.CanImplementIParsable())
        {
            baseTypes += $", global::System.IParsable<{stronglyTypedId.Name}>";
        }

        if (stronglyTypedId.CanImplementISpanParsable())
        {
            baseTypes += $", global::System.ISpanParsable<{stronglyTypedId.Name}>";
        }

        var attributes = (CSharpGeneratedFileWriter writer) =>
        {
            if (stronglyTypedId.CanGenerateTypeConverter())
            {
                writer.WriteLine($"[global::System.ComponentModel.TypeConverterAttribute(typeof({stronglyTypedId.TypeConverterTypeName}))]");
            }

            if (stronglyTypedId.CanGenerateSystemTextJsonConverter())
            {
                writer.WriteLine($"[global::System.Text.Json.Serialization.JsonConverterAttribute(typeof({stronglyTypedId.SystemTextJsonConverterTypeName}))]");
            }

            if (stronglyTypedId.CanGenerateMongoDbConverter())
            {
                writer.WriteLine($"[global::MongoDB.Bson.Serialization.Attributes.BsonSerializerAttribute(typeof({stronglyTypedId.MongoDbConverterTypeName}))]");
            }

            if (stronglyTypedId.CanGenerateNewtonsoftJsonConverter())
            {
                writer.WriteLine($"[global::Newtonsoft.Json.JsonConverterAttribute(typeof({stronglyTypedId.NewtonsoftJsonConverterTypeName}))]");
            }
        };

        using (writer.BeginPartialContext(stronglyTypedId.ExistingTypeSymbol, attributes, baseTypes))
        {
            GenerateTypeMembers(writer, compilation, stronglyTypedId);
            GenerateTypeConverter(writer, stronglyTypedId);
            GenerateSystemTextJsonConverter(writer, stronglyTypedId);
            GenerateMongoDBBsonSerializationConverter(writer, stronglyTypedId);
            GenerateNewtonsoftJsonConverter(writer, stronglyTypedId);
        }

        context.AddSource(stronglyTypedId.Name + ".g.cs", writer.ToSourceText());
    }

    private static void WriteNewMember(CSharpGeneratedFileWriter writer, StronglyTypedIdInfo info, bool addNewLine)
    {
        if (addNewLine)
        {
            writer.WriteLine();
        }

        if (info.AttributeInfo.AddCodeGeneratedAttribute)
        {

            writer.WriteLine($"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Meziantou.Framework.StronglyTypedId\", \"{Version}\")]");
        }
    }

    private static AttributeInfo? GetAttributeInfo(SourceProductionContext context, SemanticModel semanticModel, ITypeSymbol attributeSymbol, INamedTypeSymbol declaredTypeSymbol)
    {
        foreach (var attribute in declaredTypeSymbol.GetAttributes())
        {
            if (!SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, attributeSymbol))
                continue;

            var arguments = attribute.ConstructorArguments;
            if (arguments.Length != 6)
                continue;

            var idTypeArgument = arguments[0];
            if (idTypeArgument.Value is not ITypeSymbol type)
                continue;

            var converters = StronglyTypedIdConverters.None;
            AddConverter(arguments[1], StronglyTypedIdConverters.System_Text_Json);
            AddConverter(arguments[2], StronglyTypedIdConverters.Newtonsoft_Json);
            AddConverter(arguments[3], StronglyTypedIdConverters.System_ComponentModel_TypeConverter);
            AddConverter(arguments[4], StronglyTypedIdConverters.MongoDB_Bson_Serialization);
            void AddConverter(TypedConstant value, StronglyTypedIdConverters converterValue)
            {
                if (value.Value is bool argumentValue && argumentValue)
                {
                    converters |= converterValue;
                }
            }

            var addCodeGeneratedAttribute = false;
            if (arguments[5].Value is bool addCodeGeneratedAttributeValue)
            {
                addCodeGeneratedAttribute = addCodeGeneratedAttributeValue;
            }

            var idType = GetIdType(semanticModel.Compilation, type);
            if (idType == null)
            {
                context.ReportDiagnostic(Diagnostic.Create(UnsuportedType, declaredTypeSymbol.Locations.FirstOrDefault(), type.ToDisplayString()));
                continue;
            }

            return new AttributeInfo(attribute.ApplicationSyntaxReference, idType.Value, type, converters, addCodeGeneratedAttribute);
        }

        return null;
    }

    private static IdType? GetIdType(Compilation compilation, ITypeSymbol symbol)
    {
        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Boolean")))
            return IdType.System_Boolean;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Byte")))
            return IdType.System_Byte;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.DateTime")))
            return IdType.System_DateTime;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.DateTimeOffset")))
            return IdType.System_DateTimeOffset;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Decimal")))
            return IdType.System_Decimal;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Double")))
            return IdType.System_Double;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Guid")))
            return IdType.System_Guid;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Half")))
            return IdType.System_Half;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Int16")))
            return IdType.System_Int16;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Int32")))
            return IdType.System_Int32;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Int64")))
            return IdType.System_Int64;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Int128")))
            return IdType.System_Int128;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Numerics.BigInteger")))
            return IdType.System_Numerics_BigInteger;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.SByte")))
            return IdType.System_SByte;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Single")))
            return IdType.System_Single;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.String")))
            return IdType.System_String;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.UInt16")))
            return IdType.System_UInt16;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.UInt32")))
            return IdType.System_UInt32;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.UInt64")))
            return IdType.System_UInt64;

        if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.UInt128")))
            return IdType.System_UInt128;

        return null;
    }

    private static string GetTypeReference(IdType type)
    {
        return type switch
        {
            IdType.System_Boolean => "bool",
            IdType.System_Byte => "byte",
            IdType.System_DateTime => "global::System.DateTime",
            IdType.System_DateTimeOffset => "global::System.DateTimeOffset",
            IdType.System_Decimal => "decimal",
            IdType.System_Double => "double",
            IdType.System_Guid => "global::System.Guid",
            IdType.System_Half => "global::System.Half",
            IdType.System_Int16 => "short",
            IdType.System_Int32 => "int",
            IdType.System_Int64 => "long",
            IdType.System_Int128 => "global::System.Int128",
            IdType.System_Numerics_BigInteger => "global::System.Numerics.BigInteger",
            IdType.System_SByte => "sbyte",
            IdType.System_Single => "float",
            IdType.System_String => "string",
            IdType.System_UInt16 => "ushort",
            IdType.System_UInt32 => "uint",
            IdType.System_UInt64 => "ulong",
            IdType.System_UInt128 => "global::System.UInt128",
            _ => throw new ArgumentException("Type not supported", nameof(type)),
        };
    }

    private static bool IsNullable(IdType idType)
    {
        return idType == IdType.System_String;
    }

    private static string GetShortName(IdType type)
    {
        return type switch
        {
            IdType.System_Boolean => "Boolean",
            IdType.System_Byte => "Byte",
            IdType.System_DateTime => "DateTime",
            IdType.System_DateTimeOffset => "DateTimeOffset",
            IdType.System_Decimal => "Decimal",
            IdType.System_Double => "Double",
            IdType.System_Guid => "Guid",
            IdType.System_Half => "Half",
            IdType.System_Int16 => "Int16",
            IdType.System_Int32 => "Int32",
            IdType.System_Int64 => "Int64",
            IdType.System_Int128 => "Int128",
            IdType.System_Numerics_BigInteger => "BigInteger",
            IdType.System_SByte => "SByte",
            IdType.System_Single => "Single",
            IdType.System_String => "String",
            IdType.System_UInt16 => "UInt16",
            IdType.System_UInt32 => "UInt32",
            IdType.System_UInt64 => "UInt64",
            IdType.System_UInt128 => "UInt128",
            _ => throw new ArgumentException("Type not supported", nameof(type)),
        };
    }

    private static string GetPrivateOrProtectedModifier(StronglyTypedIdInfo type)
    {
        if (type.IsReferenceType && !type.IsSealed)
            return "protected";

        return "private";
    }

    private sealed record AttributeInfo(SyntaxReference? AttributeOwner, IdType IdType, ITypeSymbol IdTypeSymbol, StronglyTypedIdConverters Converters, bool AddCodeGeneratedAttribute);

    private sealed record StronglyTypedIdInfo(Compilation Compilation, ISymbol ContainingSymbol, ITypeSymbol ExistingTypeSymbol, string Name, AttributeInfo AttributeInfo, TypeDeclarationSyntax TypeDeclarationSyntax)
    {
        public bool IsClass => TypeDeclarationSyntax.IsKind(SyntaxKind.ClassDeclaration);
        public bool IsRecord => TypeDeclarationSyntax.IsKind(SyntaxKind.RecordDeclaration);
        public bool IsRecordStruct => TypeDeclarationSyntax.IsKind(SyntaxKind.RecordStructDeclaration);
        public bool IsStruct => TypeDeclarationSyntax.IsKind(SyntaxKind.StructDeclaration);
        public bool IsReferenceType => IsClass || IsRecord;

        public bool IsSealed
        {
            get
            {
                foreach (var modifier in TypeDeclarationSyntax.Modifiers)
                {
                    if (modifier.IsKind(SyntaxKind.SealedKeyword))
                        return true;
                }

                return false;
            }
        }

        public bool IsCtorDefined()
        {
            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(".ctor").OfType<IMethodSymbol>()
                .Any(m => !m.IsStatic && m.Parameters.Length == 1 && SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, AttributeInfo.IdTypeSymbol));
        }

        public bool IsFieldDefined()
        {
            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(FieldName).Any();
        }

        public bool IsValueDefined()
        {
            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(PropertyName).Any();
        }

        public bool IsValueAsStringDefined()
        {
            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(PropertyAsStringName).Any();
        }

        public bool IsToStringDefined()
        {
            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(nameof(ToString)).OfType<IMethodSymbol>()
                .Any(m => !m.IsStatic && m.Parameters.Length == 0 && m.ReturnType?.SpecialType == SpecialType.System_String);
        }

        public bool IsGetHashcodeDefined()
        {
            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(nameof(GetHashCode)).OfType<IMethodSymbol>()
                .Any(m => !m.IsStatic && m.Parameters.Length == 0 && m.ReturnType?.SpecialType == SpecialType.System_Int32);
        }

        public bool IsEqualsDefined()
        {
            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(nameof(Equals)).OfType<IMethodSymbol>()
                .Any(m => !m.IsStatic && m.Parameters.Length == 1 && m.Parameters[0].Type.SpecialType == SpecialType.System_Object && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
        }

        public bool IsIEquatableEqualsDefined()
        {
            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(nameof(Equals)).OfType<IMethodSymbol>()
                .Any(m => !m.IsStatic && m.Parameters.Length == 1 && SymbolEqualityComparer.Default.Equals(ExistingTypeSymbol, m.Parameters[0].Type) && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
        }

        public bool IsOpEqualsDefined()
        {
            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers("op_Equality").OfType<IMethodSymbol>()
                .Any(m => m.IsStatic && m.Parameters.Length == 2 && SymbolEqualityComparer.Default.Equals(ExistingTypeSymbol, m.Parameters[0].Type) && SymbolEqualityComparer.Default.Equals(ExistingTypeSymbol, m.Parameters[1].Type) && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
        }

        public bool IsOpNotEqualsDefined()
        {
            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers("op_Inequality").OfType<IMethodSymbol>()
                .Any(m => m.IsStatic && m.Parameters.Length == 2 && SymbolEqualityComparer.Default.Equals(ExistingTypeSymbol, m.Parameters[0].Type) && SymbolEqualityComparer.Default.Equals(ExistingTypeSymbol, m.Parameters[1].Type) && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
        }

        public bool IsTryParseDefined_String()
        {
            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers("TryParse").OfType<IMethodSymbol>()
                .Any(m => m.IsStatic && m.Parameters.Length > 0 && m.Parameters[0].Type.SpecialType == SpecialType.System_String);
        }

        public bool IsTryParseDefined_ReadOnlySpan()
        {
            var type = GetReadOnlySpanChar();
            if (type == null)
                return false;

            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers("TryParse").OfType<IMethodSymbol>()
                .Any(m => m.IsStatic && m.Parameters.Length > 0 && SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, type));
        }

        public bool IsParseDefined_String()
        {
            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers("Parse").OfType<IMethodSymbol>()
                .Any(m => m.IsStatic && m.Parameters.Length > 0 && m.Parameters[0].Type.SpecialType == SpecialType.System_String);
        }

        public bool IsParseDefined_Span()
        {
            var type = GetReadOnlySpanChar();
            if (type == null)
                return false;

            return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers("Parse").OfType<IMethodSymbol>()
                .Any(m => m.IsStatic && m.Parameters.Length > 0 && SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, type));
        }

        public bool SupportReadOnlySpan() => GetReadOnlySpanChar() != null;

        private ITypeSymbol? GetReadOnlySpanChar()
        {
            var readOnlySpan = Compilation.GetTypeByMetadataName("System.ReadOnlySpan`1");
            var charSymbol = Compilation.GetTypeByMetadataName("System.Char");
            if (readOnlySpan != null && charSymbol != null)
                return readOnlySpan.Construct(charSymbol);

            return null;
        }

        public bool CanUseStaticInterface()
        {
            if (Compilation.SyntaxTrees.FirstOrDefault()?.Options is CSharpParseOptions options)
                return options.LanguageVersion == LanguageVersion.Preview;

            return false;
        }

        public bool CanImplementISpanParsable()
        {
            return CanUseStaticInterface() && SupportReadOnlySpan() && Compilation.GetTypeByMetadataName("System.ISpanParsable`1") != null;
        }

        public bool CanImplementIParsable()
        {
            return CanUseStaticInterface() && SupportReadOnlySpan() && Compilation.GetTypeByMetadataName("System.IParsable`1") != null;
        }

        public bool CanGenerateTypeConverter()
        {
            return AttributeInfo.Converters.HasFlag(StronglyTypedIdConverters.System_ComponentModel_TypeConverter)
                && Compilation.GetTypeByMetadataName("System.ComponentModel.TypeConverter") != null;
        }

        public bool CanGenerateSystemTextJsonConverter()
        {
            return AttributeInfo.Converters.HasFlag(StronglyTypedIdConverters.System_Text_Json)
                && Compilation.GetTypeByMetadataName("System.Text.Json.Serialization.JsonConverter`1") != null;
        }

        public bool CanGenerateNewtonsoftJsonConverter()
        {
            return AttributeInfo.Converters.HasFlag(StronglyTypedIdConverters.Newtonsoft_Json)
                && Compilation.GetTypeByMetadataName("Newtonsoft.Json.JsonConverter") != null;
        }

        public bool CanGenerateMongoDbConverter()
        {
            return AttributeInfo.Converters.HasFlag(StronglyTypedIdConverters.MongoDB_Bson_Serialization)
                && Compilation.GetTypeByMetadataName("MongoDB.Bson.Serialization.Serializers.SerializerBase`1") != null;
        }

        public string TypeConverterTypeName => Name + "TypeConverter";
        public string SystemTextJsonConverterTypeName => Name + "JsonConverter";
        public string NewtonsoftJsonConverterTypeName => Name + "NewtonsoftJsonConverter";
        public string MongoDbConverterTypeName => Name + "BsonConverter";
    }

    [Flags]
    private enum StronglyTypedIdConverters
    {
        None = 0x0,
        System_Text_Json = 0x1,
        Newtonsoft_Json = 0x2,
        System_ComponentModel_TypeConverter = 0x4,
        MongoDB_Bson_Serialization = 0x8,
    }

    private enum IdType
    {
        System_Boolean,
        System_Byte,
        System_DateTime,
        System_DateTimeOffset,
        System_Decimal,
        System_Double,
        System_Guid,
        System_Half,
        System_Int16,
        System_Int32,
        System_Int64,
        System_Int128,
        System_Numerics_BigInteger,
        System_SByte,
        System_Single,
        System_String,
        System_UInt16,
        System_UInt32,
        System_UInt64,
        System_UInt128,
    }
}
